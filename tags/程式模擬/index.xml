<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>程式模擬 on 遊戲數學</title>
    <link>https://brianchophi.github.io/tags/%E7%A8%8B%E5%BC%8F%E6%A8%A1%E6%93%AC/</link>
    <description>Recent content in 程式模擬 on 遊戲數學</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Mon, 15 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://brianchophi.github.io/tags/%E7%A8%8B%E5%BC%8F%E6%A8%A1%E6%93%AC/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>符文大地傳說遠征模型</title>
      <link>https://brianchophi.github.io/post/lor-arena-7wins/</link>
      <pubDate>Mon, 15 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://brianchophi.github.io/post/lor-arena-7wins/</guid>
      <description>符文大地傳說遠征模型 命題 求實力要多少才能有一半的機率用一枚代幣獲得七勝獎勵
 實力表示每一局勝利的機率(期望勝率) 此篇計算以固定值表示  符文大地傳說遠征規則  七勝出場 連續兩敗出場 挑戰第七勝時僅有一次敗局機會 每枚代幣共可參加兩場 兩場中成績較優者為獎勵發放條件  每場可能性 敗敗:0勝敗勝敗敗:1勝 敗勝敗勝敗敗:2勝敗勝敗勝敗勝敗敗:3勝敗勝敗勝敗勝敗勝敗敗:4勝敗勝敗勝敗勝敗勝敗勝敗敗:5勝敗勝敗勝敗勝敗勝敗勝敗勝敗:6勝敗勝敗勝敗勝敗勝敗勝敗勝勝:7勝...勝勝勝勝勝勝勝:7勝解題 機率公式 \begin{align} P_{win0}&amp;amp;=(1-p)^2 \cr P _ {winN} &amp;amp;= \sum _ {i=0} ^ n C _ i^n p^n \times (1-p) ^ {2+i} \cr P _ {win6} &amp;amp;= \sum _ {i=0} ^ 6 C _ i^6 p^6 \times (1-p) ^ {1+i} \cr P _ {win7} &amp;amp;= \sum _ {i=0} ^ 6 C _ i^6 p^7 \times(1-p) ^ {i} \end{align}</description>
    </item>
    
    <item>
      <title>可重複中獎模型</title>
      <link>https://brianchophi.github.io/post/cal-repeated-wins-method/</link>
      <pubDate>Fri, 12 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://brianchophi.github.io/post/cal-repeated-wins-method/</guid>
      <description>可重複中獎模型 命題  一公司尾牙共計要發出１００個獎項 可參與抽獎的人數共４０人 中獎者仍有抽獎資格(可中複數的獎項)  解題 某人都沒中的機率 $(39/40)^{100} ~= 7.951$%
40個人裡有人沒中的機率 數學模型 根據數學排容原理：有一個沒中的機率－有兩人沒中的機率＋有三人沒中的機率．．．
$C_1^{40}(39/40)^{100}-C_2^{40}(38/40)^{100}+C_3^{40}(37/40)^{100}&amp;hellip;C_{39}^{40}(1/40)^{100} \approx 0.97686$%
模擬模型 根據蒙地卡羅法進行快速估算 $\approx 97.3$%
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;time&amp;#34; ) func main() { rand.Seed(time.Now().UnixNano()) count := 0 times := 100000 for i := 0; i &amp;lt; times; i++ { if getDev() { count++ } } fmt.Println(float64(count) / float64(times)) } func getDev() bool { stat := map[int]int{} for i := 0; i &amp;lt;= 100; i++ { a := rand.</description>
    </item>
    
  </channel>
</rss>
